---
title: "Filesystems"
author: "Presented by Trevor"
---

<marquee behavior="alternate" direction="up" scrollamount="25"><marquee behavior="alternate" scrollamount="50">
<h1> WELCOME TO CWRU LINUX CLUB </h1>
</marquee></marquee>

# 1: Intro to Filesystems

## What is a Filesystem

The way your computer stores information as files in an organized manner.
Stored as a tree, with folders and files.

- Files and Folders as a tree structure

```
> tree /boot

/boot
├── EFI
│   ├── BOOT
│   │   └── BOOTX64.EFI
│   ├── Linux
│   ├── nixos
│   │   ├── 3wpmjs32cmbsrxdj2pn3a04hcrfyxzsj-linux-6.16.6-bzImage.efi
│   │   ├── 7kbjk7q5nyhvl6fgyygiwad84wb16jy8-initrd-linux-6.16.6-initrd.efi
│   └── systemd
│       └── systemd-bootx64.efi
└── loader
    ├── entries
    │   ├── nixos-generation-392.conf
    │   ├── nixos-generation-393.conf
    │   └── nixos-generation-394.conf
    ├── entries.srel
    ├── loader.conf
    └── random-seed
```

## Things we want out of a Filesystem

:::{.columns}
:::{.column}
- Abstraction
- Security
- Soverignty
- Durability (Error Correction)
- Redundancy
:::
:::{.column}
- Performance
- Scalability
- Atomicity
- Efficiency
- Versioning
:::
:::

## Filesystem Concepts

:::{.columns}
:::{.column}
- Permissions
- Journaling
- Linking
- Deduplication
:::
:::{.column}
- Metadata
- Copy on Write
- Inodes / Dentries
- Blocks, Superblocks, Extents
:::
:::

## In comparison to other file storage methods

- Blob Storage
- Databases
- Content Addressable stores

# 2: Abstraction Layers of Storing Files

## Structure

:::{.center}

| |
| :-: |
| |
| Application |
| VFS |
| Filesystem |
| Page & Buffer Cache |
| LVM |
| Mdadm and Device Mapper |
| Partition Scheme |
| I/O controller |
| Physical Devices |
| |

:::

## Application Layer

:::{.columns}
:::{.column width="25%"}
| |
| :-: |
| |
| ***--- App ---*** |
| VFS |
| FS |
| Cache |
| LVM |
| Mapper |
| Partition |
| I/O |
| Devices |
| |
:::
:::{.column width="75%"}
The layer you interact with the most

- Files represented by filepathes as strings
- Utilizes Syscalls to interact with lower layers
- Most of the cli tools you use exist here

```C
FILE *fopen(char *path, char *mode);
FILE *fdopen(int fd, char *mode);
FILE *freopen(char *path, char *mode, FILE *stream);
```

```bash
podman run -it --rm alpine:latest sh -c "apk add strace && strace -e trace=file touch a"
```

:::
:::

## VFS Layer

:::{.columns}
:::{.column width="25%"}
| |
| :-: |
| |
| App |
| ***--- VFS ---*** |
| FS |
| Cache |
| LVM |
| Mapper |
| Partition |
| I/O |
| Devices |
| |
:::
:::{.column width="75%"}
The concept that all files are part of the same structure

- Fairly unique to UNIX-like systems
- Abstracts away
    - Selecting a partition
    - Caring what device we write to
- Utilizes the concept of `inodes`, `dentries`, and `files`
:::
:::

---

### VFS Terminology

- **Inode:** File or directory metadata
- **Dentry:** The structure of the FS; links `inodes` to `files`
- **File:** A binary blob that is ordered in a way to be useful
- **Superblock:** Metadata of the FS and `inodes`

## Inodes

Common `inode` operations (you're likely to recognize some of these)

```C
struct inode_operations {
    int (*create) (...);
    dentry *(*lookup) (...);
    int (*link) (...);
    int (*unlink) (...);
    int (*symlink) (...);
    dentry *(*mkdir) (...);
    int (*rmdir) (...);
    int (*mknod) (...);
    int (*rename) (...);
    int (*readlink) (...);
    char *(*get_link) (...);
    int (*permission) (...);
    int (*setattr) (...);
    int (*getattr) (...);
    ssize_t (*listxattr) (...);
    void (*update_time)(...);
    int (*atomic_open)(...);
    int (*tmpfile) (...);
    int (*fileattr_set)(...);
    int (*fileattr_get)(...);
    ...
};
```

---

### Files

A small subset of available `file` operations

```C
struct file_operations {
    module *owner;
    ssize_t (*read) (...);
    ssize_t (*write) (...);
    __poll_t (*poll) (...);
    int (*mmap) (...);
    int (*open) (...);
    int (*flush) (...);
    int (*release) (...);
    int (*fsync) (...);
    int (*lock) (...);
    int (*check_flags)(int);
    long (*fallocate)(...);
    ...
};
```

---

### Superblocks

Commands relating to the management of the entire partition

```C
struct super_operations {
    struct inode *(*alloc_inode)(super_block *sb);
    void (*destroy_inode)(inode *);
    void (*free_inode)(inode *);
    void (*dirty_inode) (inode *, int flags);
    int (*write_inode) (inode *, writeback_control *wbc);
    int (*drop_inode) (inode *);
    void (*evict_inode) (inode *);

    int (*freeze_super) (super_block *sb, freeze_holder who);
    int (*thaw_super) (super_block *sb, freeze_wholder who);

    int (*sync_fs)(super_block *sb, int wait);
    int (*freeze_fs) (super_block *);
    int (*unfreeze_fs) (super_block *);
    int (*statfs) (dentry *, kstatfs *);
    int (*remount_fs) (super_block *, int *, char *);

    int (*show_options)(seq_file *, dentry *);
    int (*show_devname)(seq_file *, dentry *);
    int (*show_path)(seq_file *, dentry *);
    int (*show_stats)(seq_file *, dentry *);

    ...
};
```

## FS Layer

:::{.columns}
:::{.column width="25%"}
| |
| :-: |
| |
| App |
| VFS |
| ***--- FS ---*** |
| Cache |
| LVM |
| Mapper |
| Partition |
| I/O |
| Devices |
| |
:::
:::{.column width="75%"}
What you probably thought this presentation was about

- Things like ext4
- Implements much of the same functions mentioned earlier
- Big variability in how it can be implemented with various features
:::
:::

---

### Ext4 Source
Actual source code from the Linux kernel
```
fs/ext4/
 ├── inode.c            // inode ops
 └── super.c, file.c, ...
```

```C
int ext4_write_inode(struct inode *inode, struct writeback_control *wbc)
{
    int err;

    if (WARN_ON_ONCE(current->flags & PF_MEMALLOC))
        return 0;

    if (EXT4_SB(inode->i_sb)->s_journal) {
        if (ext4_journal_current_handle()) {
            jbd_debug(1, "called recursively, non-PF_MEMALLOC!\n");
            dump_stack();
            return -EIO;
        }

        /*
            * No need to force transaction in WB_SYNC_NONE mode. Also
            * ext4_sync_fs() will force the commit after everything is
            * written.
            */
        if (wbc->sync_mode != WB_SYNC_ALL || wbc->for_sync)
            return 0;

        err = ext4_force_commit(inode->i_sb);
    } else {
        struct ext4_iloc iloc;

        err = __ext4_get_inode_loc(inode, &iloc, 0);
        if (err)
            return err;
        /*
            * sync(2) will flush the whole buffer cache. No need to do
            * it here separately for each inode.
            */
        if (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync)
            sync_dirty_buffer(iloc.bh);
        if (buffer_req(iloc.bh) && !buffer_uptodate(iloc.bh)) {
            EXT4_ERROR_INODE_BLOCK(inode, iloc.bh->b_blocknr,
                        "IO error syncing inode");
            err = -EIO;
        }
        brelse(iloc.bh);
    }
    return err;
}
```

---

### FS Features

:::{.columns}
:::{.column width="25%"}
| |
| :-: |
| |
| App |
| VFS |
| ***--- FS ---*** |
| Cache |
| LVM |
| Mapper |
| Partition |
| I/O |
| Devices |
| |
:::
:::{.column width="75%"}
Will be covered in our FS comparison later, but includes features such as:

- Copy on Write
- Journaling
- Deduplication
:::
:::

## Page & Buffer Cache Layer

:::{.columns}
:::{.column width="25%"}
| |
| :-: |
| |
| App |
| VFS |
| FS |
| ***--- Cache ---*** |
| LVM |
| Mapper |
| Partition |
| I/O |
| Devices |
| |
:::
:::{.column width="75%"}
Consists of caching Pages and Blocks

::: {.center}
::: {.columns}
::: {.column}
**Pages**

- Caches actual full file pathes
- Directly utilized VFS
- Actually is above the FS layer
:::

::: {.column}
**Blocks**

- Caches raw disk blocks from physical drives
- Non-file info has to be cached via blocks
:::
:::
:::

:::
:::

## LVM Layer

:::{.columns}
:::{.column width="25%"}
| |
| :-: |
| |
| App |
| VFS |
| FS |
| Cache |
| ***--- LVM ---*** |
| Mapper |
| Partition |
| I/O |
| Devices |
| |
:::
:::{.column width="75%"}
Optional layer on top of physical devices

- Abstracts away the tie between devices and volumes
- Allows live relocation of partitions
- Provides additional tools like:
    - Live snapshotting
    - RAID
    - Striping
:::
:::

## RAID and Device Mapper Layer

:::{.columns}
:::{.column width="25%"}
| |
| :-: |
| |
| App |
| VFS |
| FS |
| Cache |
| LVM |
| ***--- Mapper ---*** |
| Partition |
| I/O |
| Devices |
| |
:::
:::{.column width="75%"}
Virtual devices that act like partitions

- Mapper can be used to provide an encryption layer
- MDADM is used to provide RAID

```bash
#!/usr/bin/bash
dd if=/dev/zero of=encrypted_container.img bs=1M count=2048
LOOP_DEV=$(losetup -f)
losetup $LOOP_DEV encrypted_container.img
cryptsetup luksFormat $LOOP_DEV
cryptsetup luksOpen $LOOP_DEV exfat_crypt
mkfs.exfat /dev/mapper/exfat_crypt
mkdir -p /mnt/encrypted_exfat
mount /dev/mapper/exfat_crypt /mnt/encrypted_exfat
chown $(id -u):$(id -g) /mnt/encrypted_exfat
```
:::
:::

## Partition Layer

:::{.columns}
:::{.column width="30%"}
| |
| :-: |
| |
| App |
| VFS |
| FS |
| Cache |
| LVM |
| Mapper |
| ***--- Partition ---*** |
| I/O |
| Devices |
| |
:::
:::{.column width="70%"}
Divides up entire drives into smaller portions by utilizing a partition scheme

- Enables multiple FS's on one drive
- Multiple partition schemes
    - MBR
    - GPT

```{mermaid}
flowchart TD
    subgraph Drive A
        Boot["|Boot|"]
        Root["|---Root---|"]
        Home["|----Home----|"]
    end
```
:::
:::

:::{.fragment .fade-in}
![](https://www.easeus.com/images/en/screenshot/partition-manager/disk-layout-in-disk-management-windows-11.png){.absolute bottom=10 right=10 width="500"}
:::

---

### MBR

:::{.columns}
:::{.column width="30%"}
Master Boot Record

- Stores info on first sector
- Max of 3/4 partitions
:::
:::{.column width="70%"}


| Address  | Description                    | Bytes   |
| -------- | ------------------------------ | ------- |
| `0x0000` | Bootstrap code area            | 446     |
| `0x01BE` | Partition entry 1              | 16      |
| `0x01CE` | Partition entry 2              | 16      |
| `0x01DE` | Partition entry 3              | 16      |
| `0x01EE` | Partition entry 4              | 16      |
| `0x01FE` | Boot Signature: `0x55AA`       | 2       |
|          | **Total size: 446 + 4×16 + 2** | **512** |

:::
:::

---

### GPT

:::{.columns}
:::{.column width="30%"}
GUID Partition Table

- Practically Unlimited
- LBA: logical block addresses
:::
:::{.column width="70%"}
Partition Table Header

:::{.small-table align="left"}
| Offset | Bytes | Contents                          |
| ------ | ----- | --------------------------------- |
| `0x00` | 8     | Signature "EFI PART"              |
| `0x08` | 4     | UEFI Revision number              |
| `0x0C` | 4     | Header size                       |
| `0x10` | 4     | CRC-32 of header                  |
| `0x14` | 4     | 0                                 |
| `0x18` | 8     | Current LBA Location              |
| `0x20` | 8     | Backup LBA Location               |
| `0x28` | 8     | First usable LBA for partitions   |
| `0x30` | 8     | Last usable LBA                   |
| `0x38` | 16    | Disk GUID                         |
| `0x48` | 8     | Starting LBA of partition entries |
| `0x50` | 4     | Number of partition entries       |
| `0x54` | 4     | Size of a single partition entry  |
| `0x58` | 4     | CRC-32 of partition entries       |
| `0x5C` | *     | 0 until end of block              |
:::
:::
:::

---

### GPT

:::{.columns}
:::{.column width="30%"}
GUID Partition Table

- Practically Unlimited
- LBA: logical block addresses
:::
:::{.column width="70%"}

Partition Entry

| Offset | Length | Contents              |
| ------ | ------ | --------------------- |
| `0x00` | 16     | Partition type GUID   |
| `0x10` | 16     | Unique partition GUID |
| `0x20` | 8      | First LBA             |
| `0x28` | 8      | Last LBA              |
| `0x30` | 8      | Attribute flags       |
| `0x38` | 72     | Partition name        |

:::
:::

## I/O Layer

:::{.columns}
:::{.column width="25%"}
| |
| :-: |
| |
| App |
| VFS |
| FS |
| Cache |
| LVM |
| Mapper |
| Partition |
| ***--- I/O ---*** |
| Devices |
| |
:::
:::{.column width="75%"}

Handles writing raw data as blocks

- Includes:
    - Linux I/O scheduler
    - Drivers necessary to communicate to devices
    - Physical hardware to execute those instructions

:::
:::

## Device Layer

:::{.columns}
:::{.column width="25%"}
| |
| :-: |
| |
| App |
| VFS |
| FS |
| Cache |
| LVM |
| Mapper |
| Partition |
| I/O |
| ***--- Devices ---*** |
| |
:::
:::{.column width="75%"}
The physical medium that the data is stored on

- Could be a magnetic plate or solid state
- Directly physically connected to the computer

:::
:::

# 3: Types of Filesystems

## Conventional Filesystems

Older filesystems that are still used today

| FS       | Sparse | CoW | Enc. | Comp. | Journal | Notes                      |
| -------- | ------ | --- | ---- | ----- | ------- | -------------------------- |
| ReiserFS | ✔      | ✘   | ✘    | ✘     | ✔       | First Journal              |
| Ext4     | ✔      | ✘   | ✔    | ✘     | ✔       | Has quotas                 |
| NTFS     | ✔      | ?   | ✔    | ✔     | ✘       | No UNIX permission         |
| HFS+     | ✘      | ?   | ✘    | ✘     | ✘       | Hard links to directories  |
| (ex)FAT  | ✘      | ✘   | ✘    | ✘     | ✘       | Supports nothing           | 

## Modern Filesystems

Newer filesystems that are touted for their abilities

| FS    | ECC | Multi Dev | Enc. | Notes               |
| ----- | --- | --------- | ---- | ------------------- |
| BtrFS | ✔   | ✔         | ✘    | B-trees, speedy     | 
| APFS  | ✘   | ✘         | ✔    | No Hard linked Dirs |
| ZFS   | ✔   | ✔         | ✔    | No extants          |

## Network Filesystems

::: {.columns}
::: {.column}
- NFS
- SMB
- CIFS
- IPFS
- WebDAV
:::
::: {.column}
```{mermaid}
sequenceDiagram
    User->>WebDAV: LOCK
    WebDAV-->>User: PROPFIND
    WebDAV-->>User: GET
    User->>WebDAV: PUT
    User->>WebDAV: UNLOCK
```
:::
:::

## Special Linux Filesystems

- tmpfs/ramfs
- overlayfs
- sysfs, procfs
- lukfs/fscrypt
- squashfs

```bash
#!/usr/bin/env bash

mkdir -p {tmp,merged}
mkdir -p tmp/{a,b,work}

mount -t overlay overlay -o lowerdir=./tmp/a,upperdir=./tmp/b,workdir=./work ./merged
```

# 4: Filesystems on Linux

## Filesystems on Linux

- The VFS
- Device Block Files
- Drivers as Modules
- Mounting mechanics
- Linking

## Filesystem Tools

Common Linux tools for interacting with FS's

::: {.columns}
::: {.column}
- mkfs
- dd
- fstab
- mount/umount
- fsck
- tune2fs
:::
::: {.column}
- df/du
- iotop/iostat
- (g)parted
- disko
- fallocate
:::
:::

---

### mkfs
- Formats/Creates new filesystems
- Type it out and press tab twice to see the filesystems it can create
- Journaling file systems
    - Recording pending writes to a journal
    - Keeps a log of changes to the file system before applying them.
    - You can test this on image files
        - `dd -if=/dev/zero -of=./test.img bs=1M count=250`

---

### dd
- Discussed briefly in the previous example
- Copying / converting / writing files
- Can read from /dev/zero to wipe data
- Can copy from partitions /dev/sda to backup
- can copy from disk to disk
- Can convert using thin `convert=` flag
- bs and count flag for block size
- There is a theoretical optimal blocksize

---

### etc/fstab

:::{.scrollable}
- OS file system table
- In the following format
    - File system (UUID), mount point, type, options, dump, pass
    - options:
        - auto: should it be auto mounted on boot?
        - exec: can the partition execute binaries?
        - ro/rw: Read only or read write
        - sync, async: force writing immediately on execution or wait
        - Nouser/user allows user to have mount and umount privellges
:::

---

### mount/umount
- mount/unmount images
- Usage: `sudo mount -options [image] [mountpoint]`
- Can specify the type of image with -t
- `mount -l` lists all current mounts
- `-o` can specify ro/rw for read only/read write
- `-a` Mounts all file systems listed in fstab

---

### fsck
- Check and Repair linux filesystems
- UNMOUNT FILESYSTEMS BEFORE USING FSCK
- Usage `fsck -options -t fstype [filesystem]`
- You can use a -p flag to auto apply repairs

---

### tune2fs 

:::{.scrollable}
- Usage: `sudo tune2fs [options] device`
- A ton of options. Allows you to view and change various filesystem parameters on Linux ext2, ext3, or ext4 filesystems
- List contents of a file system, Display the volume label
- Display the volume name
- View mount count and max mount count
- Change max mount count
- Display check interval
- Change/Disable check intervals
- Change the UUID of a filesystem
- Set filesystem features
:::

---

### du
- Displays disk usage
- usage: `du [options] directory`
- `du -h -d 1 [dir]` is an example to see disk usage to one level in a directory

---

### df
- du but for disk filesystems
- Shows disk utilization
- `-h` for human readable

---

### iotop/iostat
- Shows IO activity for disks
- `iostat` is under busybox and sysstat
- `iotop` can be installed directly on nixpkgs and is under toybox
- iotop is a top-like view of disk usage, iostat shows the usage at that instant

---

### gparted
- Another tool to create and format partitions
- Has a GUI

---

### lsblk
- Shows all available block devices
- Shows disk utilization and mount points as well

---

### disko
- Declarative disk partitioning tool
- Allows you to do partitioning in a config file
- Example config pulled from nixos wiki:
```nix
  { disks ? [ "/dev/vda" ], ... }: {
  disko.devices = {
    disk = {
      vdb = {
        device = builtins.elemAt disks 0;
        type = "disk";
        content = {
          type = "table";
          format = "gpt";
          partitions = [
            {
              name = "ESP";
              start = "1MiB";
              end = "500MiB";
              bootable = true;
              content = {
                type = "filesystem";
                format = "vfat";
                mountpoint = "/boot";
              };
            }
            {
              name = "root";
              start = "500MiB";
              end = "100%";
              part-type = "primary";
              content = {
                type = "filesystem";
                format = "bcachefs";
                mountpoint = "/";
              };
            }
          ];
        };
      };
    };
  };
}
```

# 5: Implementation Details

## exFAT

| |
| - |
| |
| Main Boot Region |
| Backup Boot Region |
| FAT Alignment |
| FAT 1 |
| FAT 2 |
| Cluster Heap Alignment |
| Cluster Heap |
| |

---

### Boot Region

::: {.columns}
::: {.column width="20%"}
| |
| :-: |
| |
| ***--- Boot1 ---*** |
| ***--- Boot2 ---*** |
| --- |
| FAT 1 |
| FAT 2 |
| --- |
| Heap |
| |
:::
::: {.scrollable .small-table .column width="80%"}
| Byte | Size | Name                        | Description                                                                         |
| ---- | ---- | --------------------------- | ----------------------------------------------------------------------------------- |
| 0    | 3    | JumpBoot                    | Jump instruction to the BootCode (x86 instruction). Must be `0xEB`, `0x76`, `0x90`. |
| 3    | 8    | FileSystemName              | `EXFAT   `                                                                          |
| 11   | 53   | MustBeZero                  | 0                                                                                   |
| 64   | 8    | PartitionOffset             | (Optional) Offset from beginning of physical drive                                  |
| 72   | 8    | VolumeLength                | Size of exFAT volume                                                                |
| 80   | 4    | FatOffset                   | Start sector of FAT region                                                          |
| 84   | 4    | FatLength                   | Size of FAT in sectors                                                              |
| 88   | 4    | ClusterHeapOffset           | Start sector of Heap                                                                |
| 92   | 4    | ClusterCount                | Size of Heap in sector                                                              |
| 96   | 4    | FirstClusterOfRootDirectory | Cluster number of root dir                                                          |
| 100  | 4    | VolumeSerialNumber          | Random                                                                              |
| 104  | 2    | FileSystemRevision          | Version of exFAT                                                                    |
| 106  | 2    | VolumeFlags                 | ActiveFAT, VolumeDirty, MediaFailure                                                |
| 108  | 1    | BytesPerSectorShift         | Sector size in unit of byte expressed in log2.                                      |
| 109  | 1    | SectorsPerClusterShift      | Cluster size in unit of sector expressed in log2. 1 sec=32MB                        |
| 110  | 1    | NumberOfFats                | Number of FATs and allocation bitmaps. 1/2                                          |
| 111  | 1    | DriveSelect                 | Drive number used by disk BIOS                                                      |
| 112  | 1    | PercentInUse                | Volume usage in unit of percent. 0xFF means not used.                               |
| 113  | 7    | Reserved                    | 0                                                                                   |
| 120  | 390  | BootCode                    | Boot program.                                                                       |
| 510  | 2    | BootSignature               | 0xAA55.                                                                             |
| 512  |      | Anything Extra              | 0                                                                                   |
:::
:::

---

### FAT Status

::: {.columns}
::: {.column width="20%"}
| |
| :-: |
| |
| Boot1 |
| Boot2 |
| --- |
| ***--- FAT 1 ---*** |
| ***--- FAT 2 ---*** |
| --- |
| Heap |
| |
:::
::: {.scrollable .small-table .column width="80%"}
| bitmap | FAT                         | Cluster status                 |
|--------|-----------------------------|--------------------------------|
| 0      | (Don't care)                | Free                           |
| 1      | 0 - 1                       | (Reserved)                     |
| 1      | 2 - ClusterCount+1          | In-use (value is link to next) |
| 1      | ClusterCount+2 - 0xFFFFFFF6 | (Reserved)                     |
| 1      | 0xFFFFFFF7                  | Bad cluster                    |
| 1      | 0xFFFFFFF8 - 0xFFFFFFFE     | (Reserved)                     |
| 1      | 0xFFFFFFFF                  | In-use (end of chain)          |
:::
:::

## Ext4

| |
| - |
| |
| Superblock |
| Block Group Descriptor |
| Group Descriptor Table |
| Block Bitmap |
| Inode Bitmap |
| Inode Table |
| Extent Tree |
| Hash Tree |
| Journal |
| |

:::{.fragment .fade-in}
![](https://shares.404wolf.com/first.png){.absolute top=10}
:::

:::{.fragment .fade-in}
![](https://shares.404wolf.com/second.png){.absolute top=10 right=10}
:::

---

### Superblock

Ext4 Superblock struct

```C
struct ext4_super_block {
/*00*/  __le32  s_inodes_count;         /* Inodes count */
        __le32  s_blocks_count_lo;      /* Blocks count */
        __le32  s_r_blocks_count_lo;    /* Reserved blocks count */
        __le32  s_free_blocks_count_lo; /* Free blocks count */
/*10*/  __le32  s_free_inodes_count;    /* Free inodes count */
        __le32  s_first_data_block;     /* First Data Block */
        __le32  s_log_block_size;       /* Block size */
        __le32  s_log_cluster_size;     /* Allocation cluster size */
/*20*/  __le32  s_blocks_per_group;     /* # Blocks per group */
        __le32  s_clusters_per_group;   /* # Clusters per group */
        __le32  s_inodes_per_group;     /* # Inodes per group */
        __le32  s_mtime;                /* Mount time */
/*30*/  __le32  s_wtime;                /* Write time */
        __le16  s_mnt_count;            /* Mount count */
        __le16  s_max_mnt_count;        /* Maximal mount count */
        __le16  s_magic;                /* Magic signature */
        __le16  s_state;                /* File system state */
        __le16  s_errors;               /* Behaviour when detecting errors */
        __le16  s_minor_rev_level;      /* minor revision level */
/*40*/  __le32  s_lastcheck;            /* time of last check */
        __le32  s_checkinterval;        /* max. time between checks */
        __le32  s_creator_os;           /* OS */
        __le32  s_rev_level;            /* Revision level */
/*50*/  __le16  s_def_resuid;           /* Default uid for reserved blocks */
        __le16  s_def_resgid;           /* Default gid for reserved blocks */
        /*
         * These fields are for EXT4_DYNAMIC_REV Superblocks only.
         *
         * Note: the difference between the compatible feature set and
         * the incompatible feature set is that if there is a bit set
         * in the incompatible feature set that the kernel doesn't
         * know about, it should refuse to mount the filesystem.
         *
         * e2fsck's requirements are more strict; if it doesn't know
         * about a feature in either the compatible or incompatible
         * feature set, it must abort and not try to meddle with
         * things it doesn't understand...
         */
        __le32  s_first_ino;            /* First non-reserved inode */
        __le16  s_inode_size;           /* size of inode structure */
        __le16  s_block_group_nr;       /* block group # of this Superblock */
        __le32  s_feature_compat;       /* compatible feature set */
/*60*/  __le32  s_feature_incompat;     /* incompatible feature set */
        __le32  s_feature_ro_compat;    /* readonly-compatible feature set */
/*68*/  __u8    s_uuid[16];             /* 128-bit uuid for volume */
/*78*/  char    s_volume_name[16];      /* volume name */
/*88*/  char    s_last_mounted[64] __nonstring; /* directory where last mounted */
/*C8*/  __le32  s_algorithm_usage_bitmap; /* For compression */
        /*
         * Performance hints.  Directory preallocation should only
         * happen if the EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.
         */
        __u8    s_prealloc_blocks;      /* Nr of blocks to try to preallocate*/
        __u8    s_prealloc_dir_blocks;  /* Nr to preallocate for dirs */
        __le16  s_reserved_gdt_blocks;  /* Per group desc for online growth */
        /*
         * Journaling support valid if EXT4_FEATURE_COMPAT_HAS_JOURNAL set.
         */
/*D0*/  __u8    s_journal_uuid[16];     /* uuid of journal Superblock */
/*E0*/  __le32  s_journal_inum;         /* inode number of journal file */
        __le32  s_journal_dev;          /* device number of journal file */
        __le32  s_last_orphan;          /* start of list of inodes to delete */
        __le32  s_hash_seed[4];         /* HTREE hash seed */
        __u8    s_def_hash_version;     /* Default hash version to use */
        __u8    s_jnl_backup_type;
        __le16  s_desc_size;            /* size of group descriptor */
/*100*/ __le32  s_default_mount_opts;
        __le32  s_first_meta_bg;        /* First metablock block group */
        __le32  s_mkfs_time;            /* When the filesystem was created */
        __le32  s_jnl_blocks[17];       /* Backup of the journal inode */
        /* 64bit support valid if EXT4_FEATURE_COMPAT_64BIT */
/*150*/ __le32  s_blocks_count_hi;      /* Blocks count */
        __le32  s_r_blocks_count_hi;    /* Reserved blocks count */
        __le32  s_free_blocks_count_hi; /* Free blocks count */
        __le16  s_min_extra_isize;      /* All inodes have at least # bytes */
        __le16  s_want_extra_isize;     /* New inodes should reserve # bytes */
        __le32  s_flags;                /* Miscellaneous flags */
        __le16  s_raid_stride;          /* RAID stride */
        __le16  s_mmp_update_interval;  /* # seconds to wait in MMP checking */
        __le64  s_mmp_block;            /* Block for multi-mount protection */
        __le32  s_raid_stripe_width;    /* blocks on all data disks (N*stride)*/
        __u8    s_log_groups_per_flex;  /* FLEX_BG group size */
        __u8    s_checksum_type;        /* metadata checksum algorithm used */
        __u8    s_encryption_level;     /* versioning level for encryption */
        __u8    s_reserved_pad;         /* Padding to next 32bits */
        __le64  s_kbytes_written;       /* nr of lifetime kilobytes written */
        __le32  s_snapshot_inum;        /* Inode number of active snapshot */
        __le32  s_snapshot_id;          /* sequential ID of active snapshot */
        __le64  s_snapshot_r_blocks_count; /* reserved blocks for active
                                              snapshot's future use */
        __le32  s_snapshot_list;        /* inode number of the head of the
                                           on-disk snapshot list */
#define EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)
        __le32  s_error_count;          /* number of fs errors */
        __le32  s_first_error_time;     /* first time an error happened */
        __le32  s_first_error_ino;      /* inode involved in first error */
        __le64  s_first_error_block;    /* block involved of first error */
        __u8    s_first_error_func[32] __nonstring;     /* function where the error happened */
        __le32  s_first_error_line;     /* line number where error happened */
        __le32  s_last_error_time;      /* most recent time of an error */
        __le32  s_last_error_ino;       /* inode involved in last error */
        __le32  s_last_error_line;      /* line number where error happened */
        __le64  s_last_error_block;     /* block involved of last error */
        __u8    s_last_error_func[32] __nonstring;      /* function where the error happened */
#define EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)
        __u8    s_mount_opts[64];
        __le32  s_usr_quota_inum;       /* inode for tracking user quota */
        __le32  s_grp_quota_inum;       /* inode for tracking group quota */
        __le32  s_overhead_clusters;    /* overhead blocks/clusters in fs */
        __le32  s_backup_bgs[2];        /* groups with sparse_super2 SBs */
        __u8    s_encrypt_algos[4];     /* Encryption algorithms in use  */
        __u8    s_encrypt_pw_salt[16];  /* Salt used for string2key algorithm */
        __le32  s_lpf_ino;              /* Location of the lost+found inode */
        __le32  s_prj_quota_inum;       /* inode for tracking project quota */
        __le32  s_checksum_seed;        /* crc32c(uuid) if csum_seed set */
        __u8    s_wtime_hi;
        __u8    s_mtime_hi;
        __u8    s_mkfs_time_hi;
        __u8    s_lastcheck_hi;
        __u8    s_first_error_time_hi;
        __u8    s_last_error_time_hi;
        __u8    s_pad[2];
        __le16  s_encoding;             /* Filename charset encoding */
        __le16  s_encoding_flags;       /* Filename charset encoding flags */
        __le32  s_reserved[95];         /* Padding to the end of the block */
        __le32  s_checksum;             /* crc32c(Superblock) */
};
```

# Sources

:::{.smaller .scrollable}
- https://www.kernel.org/doc/html/latest/filesystems/vfs.html
- https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/12_FileSystemImplementation.html
- https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/ext4/super.c
- https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/9/html/configuring_and_managing_logical_volumes/overview-of-logical-volume-management_configuring-and-managing-logical-volumes

- https://en.wikipedia.org/wiki/GUID_Partition_Table
- https://en.wikipedia.org/wiki/Master_boot_record
- https://blogs.oracle.com/linux/post/understanding-ext4-disk-layout-part-1
- https://www.c-jump.com/bcc/t256t/Week13exFAT/Week13exFAT.html#W13_0070_exfat_volume_layout_

- https://www.howtogeek.com/38125/htg-explains-what-is-the-linux-fstab-and-how-does-it-work/
- https://www.golinuxcloud.com/tune2fs-command-in-linux/
- https://linuxhandbook.com/fsck-command/
- https://www.geeksforgeeks.org/linux-unix/linux-tune2fs-command-with-examples/
- https://linuxtechlab.com/du-df-commands-examples/
- https://nixos.wiki/wiki/Disko
:::